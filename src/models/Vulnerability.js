const mongoose = require('mongoose');

const vulnerabilitySchema = new mongoose.Schema({
  // Identificación
  name: {
    type: String,
    required: true,
    trim: true,
    maxlength: 200
  },
  description: {
    type: String,
    required: true,
    maxlength: 1000
  },
  
  // Clasificación MAGERIT
  type: {
    type: String,
    required: true,
    enum: [
      'technical',           // Vulnerabilidades técnicas
      'organizational',      // Vulnerabilidades organizacionales
      'physical',           // Vulnerabilidades físicas
      'human'               // Vulnerabilidades humanas
    ]
  },
  
  category: {
    type: String,
    required: true,
    enum: [
      // Técnicas
      'software_vulnerabilities',
      'hardware_vulnerabilities', 
      'network_vulnerabilities',
      'cryptographic_vulnerabilities',
      
      // Organizacionales
      'policy_gaps',
      'procedure_gaps',
      'training_gaps',
      'awareness_gaps',
      
      // Físicas
      'facility_vulnerabilities',
      'environmental_vulnerabilities',
      'access_control_vulnerabilities',
      
      // Humanas
      'skill_gaps',
      'social_engineering_susceptibility',
      'insider_threat_vulnerability'
    ]
  },
  
  // Nivel de vulnerabilidad (0-1)
  vulnerabilityLevel: {
    type: Number,
    required: true,
    min: 0,
    max: 1,
    // 0 = sin vulnerabilidad, 1 = vulnerabilidad crítica
  },
  
  // Nivel cualitativo
  severityLevel: {
    type: String,
    required: true,
    enum: ['very_low', 'low', 'medium', 'high', 'critical']
  },
  
  // Activo al que afecta
  asset: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Asset',
    required: true
  },
  
  // Amenazas que pueden explotar esta vulnerabilidad
  exploitableBy: [{
    threat: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Threat'
    },
    exploitabilityFactor: {
      type: Number,
      min: 0,
      max: 3,
      default: 1
      // Factor que modifica la probabilidad de la amenaza
    }
  }],
  
  // Dimensiones de seguridad afectadas
  affectedDimensions: {
    confidentiality: {
      impact: {
        type: Number,
        min: 0,
        max: 1,
        default: 0
      }
    },
    integrity: {
      impact: {
        type: Number,
        min: 0,
        max: 1,
        default: 0
      }
    },
    availability: {
      impact: {
        type: Number,
        min: 0,
        max: 1,
        default: 0
      }
    },
    authenticity: {
      impact: {
        type: Number,
        min: 0,
        max: 1,
        default: 0
      }
    },
    traceability: {
      impact: {
        type: Number,
        min: 0,
        max: 1,
        default: 0
      }
    }
  },
  
  // Evaluación técnica detallada
  technicalAssessment: {
    discoveryMethod: {
      type: String,
      enum: ['automated_scan', 'manual_review', 'penetration_test', 'audit', 'incident_response', 'third_party_report']
    },
    discoveryDate: {
      type: Date,
      default: Date.now
    },
    verificationStatus: {
      type: String,
      enum: ['unverified', 'verified', 'false_positive', 'risk_accepted'],
      default: 'unverified'
    },
    exploitComplexity: {
      type: String,
      enum: ['low', 'medium', 'high'],
      default: 'medium'
    },
    accessRequired: {
      type: String,
      enum: ['none', 'user', 'admin', 'physical'],
      default: 'user'
    }
  },
  
  // Integración CVE
  cveDetails: {
    cveId: {
      type: String,
      match: /^CVE-\d{4}-\d{4,}$/
    },
    cvssV3Score: {
      type: Number,
      min: 0,
      max: 10
    },
    cvssV3Vector: {
      type: String
    },
    cweId: {
      type: String,
      match: /^CWE-\d+$/
    },
    nvdPublishDate: {
      type: Date
    },
    lastModifiedDate: {
      type: Date
    },
    references: [{
      url: String,
      source: String
    }]
  },
  
  // Factor de exposición temporal
  temporalMetrics: {
    exploitCodeMaturity: {
      type: String,
      enum: ['unproven', 'proof_of_concept', 'functional', 'high'],
      default: 'unproven'
    },
    remediationLevel: {
      type: String,
      enum: ['official_fix', 'temporary_fix', 'workaround', 'unavailable'],
      default: 'unavailable'
    },
    reportConfidence: {
      type: String,
      enum: ['unknown', 'reasonable', 'confirmed'],
      default: 'reasonable'
    }
  },
  
  // Métricas de contexto organizacional
  environmentalMetrics: {
    businessImpact: {
      type: Number,
      min: 0,
      max: 1,
      default: 0.5
    },
    exposureLevel: {
      type: String,
      enum: ['internal', 'partner', 'public'],
      default: 'internal'
    },
    dataClassification: {
      type: String,
      enum: ['public', 'internal', 'confidential', 'restricted'],
      default: 'internal'
    }
  },
  
  // Remediación y controles
  remediation: {
    status: {
      type: String,
      enum: ['open', 'in_progress', 'resolved', 'risk_accepted', 'false_positive'],
      default: 'open'
    },
    priority: {
      type: String,
      enum: ['low', 'medium', 'high', 'critical'],
      required: true
    },
    assignedTo: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    dueDate: {
      type: Date
    },
    estimatedEffort: {
      type: Number,
      // Horas estimadas para remediar
    },
    estimatedCost: {
      type: Number,
      // Costo estimado en USD
    },
    appliedControls: [{
      control: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Control'
      },
      effectiveness: {
        type: Number,
        min: 0,
        max: 1
        // Efectividad del control contra esta vulnerabilidad
      },
      implementationDate: {
        type: Date
      }
    }],
    remediationNotes: {
      type: String,
      maxlength: 2000
    }
  },
  
  // Historial de cambios
  riskHistory: [{
    date: {
      type: Date,
      default: Date.now
    },
    vulnerabilityLevel: Number,
    severityLevel: String,
    reason: String,
    changedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    }
  }],
  
  // Metadatos organizacionales
  organization: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Organization',
    required: true
  },
  
  // Auditoria
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  updatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  
  // Control de versiones
  version: {
    type: String,
    default: '1.0'
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Índices para optimización
vulnerabilitySchema.index({ organization: 1, asset: 1 });
vulnerabilitySchema.index({ organization: 1, 'remediation.status': 1 });
vulnerabilitySchema.index({ organization: 1, severityLevel: 1 });
vulnerabilitySchema.index({ 'cveDetails.cveId': 1 });
vulnerabilitySchema.index({ 'remediation.dueDate': 1, 'remediation.status': 1 });

// Virtual para calcular puntuación de riesgo cuantitativa
vulnerabilitySchema.virtual('riskScore').get(function() {
  const baseScore = this.vulnerabilityLevel;
  
  // Ajustar por métricas temporales
  let temporalMultiplier = 1.0;
  if (this.temporalMetrics.exploitCodeMaturity === 'high') temporalMultiplier += 0.3;
  else if (this.temporalMetrics.exploitCodeMaturity === 'functional') temporalMultiplier += 0.2;
  else if (this.temporalMetrics.exploitCodeMaturity === 'proof_of_concept') temporalMultiplier += 0.1;
  
  // Ajustar por exposición
  let exposureMultiplier = 1.0;
  if (this.environmentalMetrics.exposureLevel === 'public') exposureMultiplier = 1.5;
  else if (this.environmentalMetrics.exposureLevel === 'partner') exposureMultiplier = 1.2;
  
  return Math.min(baseScore * temporalMultiplier * exposureMultiplier, 1.0);
});

// Virtual para días hasta vencimiento
vulnerabilitySchema.virtual('daysUntilDue').get(function() {
  if (!this.remediation.dueDate) return null;
  
  const today = new Date();
  const dueDate = new Date(this.remediation.dueDate);
  const diffTime = dueDate - today;
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
});

// Método para calcular factor de explotabilidad por amenaza
vulnerabilitySchema.methods.getExploitabilityFactor = function(threatId) {
  const exploitableByThreat = this.exploitableBy.find(
    exploit => exploit.threat.toString() === threatId.toString()
  );
  return exploitableByThreat ? exploitableByThreat.exploitabilityFactor : 0;
};

// Método para calcular impacto total ponderado
vulnerabilitySchema.methods.calculateWeightedImpact = function(assetValuation) {
  if (!assetValuation) return 0;
  
  const weights = {
    confidentiality: assetValuation.confidentiality || 0,
    integrity: assetValuation.integrity || 0,
    availability: assetValuation.availability || 0,
    authenticity: assetValuation.authenticity || 0,
    traceability: assetValuation.traceability || 0
  };
  
  let totalImpact = 0;
  let totalWeight = 0;
  
  for (const [dimension, impact] of Object.entries(this.affectedDimensions)) {
    const weight = weights[dimension] || 0;
    totalImpact += impact.impact * weight;
    totalWeight += weight;
  }
  
  return totalWeight > 0 ? totalImpact / totalWeight : 0;
};

// Método para actualizar historial de riesgo
vulnerabilitySchema.methods.updateRiskHistory = function(newLevel, reason, userId) {
  this.riskHistory.push({
    date: new Date(),
    vulnerabilityLevel: this.vulnerabilityLevel,
    severityLevel: this.severityLevel,
    reason: reason,
    changedBy: userId
  });
  
  this.vulnerabilityLevel = newLevel;
  
  // Actualizar severityLevel basado en vulnerabilityLevel
  if (newLevel >= 0.9) this.severityLevel = 'critical';
  else if (newLevel >= 0.7) this.severityLevel = 'high';
  else if (newLevel >= 0.5) this.severityLevel = 'medium';
  else if (newLevel >= 0.3) this.severityLevel = 'low';
  else this.severityLevel = 'very_low';
};

// Middleware pre-save para validaciones
vulnerabilitySchema.pre('save', function(next) {
  // Sincronizar severityLevel con vulnerabilityLevel
  if (this.vulnerabilityLevel >= 0.9) this.severityLevel = 'critical';
  else if (this.vulnerabilityLevel >= 0.7) this.severityLevel = 'high';
  else if (this.vulnerabilityLevel >= 0.5) this.severityLevel = 'medium';
  else if (this.vulnerabilityLevel >= 0.3) this.severityLevel = 'low';
  else this.severityLevel = 'very_low';
  
  // Validar que al menos una dimensión tenga impacto
  const hasImpact = Object.values(this.affectedDimensions).some(dim => dim.impact > 0);
  if (!hasImpact) {
    return next(new Error('Al menos una dimensión debe tener impacto mayor a 0'));
  }
  
  next();
});

// Método estático para obtener vulnerabilidades críticas pendientes
vulnerabilitySchema.statics.getCriticalPending = async function(organizationId) {
  return await this.find({
    organization: organizationId,
    severityLevel: { $in: ['critical', 'high'] },
    'remediation.status': { $in: ['open', 'in_progress'] }
  })
  .populate('asset', 'name type')
  .populate('remediation.assignedTo', 'firstName lastName email')
  .sort({ vulnerabilityLevel: -1, 'remediation.dueDate': 1 });
};

// Método estático para estadísticas de vulnerabilidades
vulnerabilitySchema.statics.getOrganizationStats = async function(organizationId) {
  const stats = await this.aggregate([
    { $match: { organization: organizationId } },
    {
      $group: {
        _id: '$severityLevel',
        count: { $sum: 1 },
        avgLevel: { $avg: '$vulnerabilityLevel' }
      }
    }
  ]);
  
  const statusStats = await this.aggregate([
    { $match: { organization: organizationId } },
    {
      $group: {
        _id: '$remediation.status',
        count: { $sum: 1 }
      }
    }
  ]);
  
  return { severityStats: stats, statusStats: statusStats };
};

module.exports = mongoose.model('Vulnerability', vulnerabilitySchema);